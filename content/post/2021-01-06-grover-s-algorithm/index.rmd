---
title: Grover's Algorithm
date: '2021-01-06'
---
<center>
</br>
<img src="https://spectrum.ieee.org/image/MzEwMTk5OA.jpeg">
</center>
```{r}
library("reticulate")
library("Rcpp")
py_install("r-reticulate", "qiskit")
py_install("qiskit")
```

```{python}
#Setup
import qiskit as qk
from qiskit import IBMQ
IBMQ.save_account('ee9c9da0c83a6c001e34e8e124afbceb074dedb0e93b4fb8995b0bbce8a75a2eb47538c95204f2a43923abf260a79e72d9bba4b279ffc5950e39396804f43984')
```


The **Grover Algorithm** is a search function which returns "True" for one of its possible inputs, and "False" for all the others; its purpose is to find any object in the database that would return "True". Grover's algorithm has a lot of applications, and can be used for estimating the mean and median of a set of numbers, and for solving the collision problem. In addition, it can be used to perform exhaustive searches over the set of possible solution. It is the fastest possible quantum algorithm for searching an unsorted database.

Grover's algorithm was designed to speed up an unstructured database search quadratically. It is comprised of Hadamard gates, an oracle, controlled-Z gates, and a reflection. We will discuss each of these pieces in turn. First, here is a visual representation of the Grover circuit:


```{python}
from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
from numpy import pi

qreg_q = QuantumRegister(2, 'q')
creg_c = ClassicalRegister(2, 'c')
circuit = QuantumCircuit(qreg_q, creg_c)

circuit.reset(qreg_q[0])
circuit.reset(qreg_q[1])
circuit.h(qreg_q[1])
circuit.h(qreg_q[0])
circuit.cz(qreg_q[0], qreg_q[1])
circuit.h(qreg_q[1])
circuit.h(qreg_q[0])
circuit.x(qreg_q[0])
circuit.x(qreg_q[1])
circuit.cz(qreg_q[0], qreg_q[1])
circuit.x(qreg_q[0])
circuit.x(qreg_q[1])
circuit.h(qreg_q[0])
circuit.h(qreg_q[1])
circuit.measure(qreg_q[0], creg_c[0])
circuit.measure(qreg_q[1], creg_c[1])
print (circuit)
```

*How does the seach work?*
Suppose you are given a large list of $N$ items. Among these items there is one item with a unique property that we wish to locate called $w$. In general, <i>n</i> qubits are represented by a superposition state vector in $2^{n}$ dimensional Hilbert space, so our database contains $N=2^n$ items, which is dependent on the number of qubits.

In classical computation, the search (on average) would require checking $N/2$ items, and at worst all $N$ items. On a quantum computer, however, we can find the marked item in roughly $\sqrt{N}$ steps with Grover's algorithm, which is a significant improvement to computational efficiency. Since the algorithm does not depend on the structure of the database itself, it can be used more generically.




[here](https://wucrypto-project.netlify.app/).

*Image from Spectrum.ieee*
