---
title: Grover's Algorithm
date: '2021-01-06'
---

<script src="{{< blogdown/postref >}}index_files/header-attrs/header-attrs.js"></script>


<center>
</br>
<img src="https://spectrum.ieee.org/image/MzEwMTk5OA.jpeg">
</center>
<pre class="r"><code>#library(&quot;reticulate&quot;)
#library(&quot;Rcpp&quot;)
#py_install(&quot;r-reticulate&quot;, &quot;qiskit&quot;)
#py_install(&quot;qiskit&quot;)</code></pre>
<pre class="python"><code>#Setup
#import qiskit as qk
#from qiskit import IBMQ
#IBMQ.save_account(&#39;ee9c9da0c83a6c001e34e8e124afbceb074dedb0e93b4fb8995b0bbce8a75a2eb47538c95204f2a43923abf260a79e72d9bba4b279ffc5950e39396804f43984&#39;)</code></pre>
<p>The <strong>Grover Algorithm</strong> is a search function which returns “True” for one of its possible inputs, and “False” for all the others; its purpose is to find any object in the database that would return “True”. Grover’s algorithm has a lot of applications, and can be used for estimating the mean and median of a set of numbers, and for solving the collision problem. In addition, it can be used to perform exhaustive searches over the set of possible solution. It is the fastest possible quantum algorithm for searching an unsorted database.</p>
<p>Grover’s algorithm was designed to speed up an unstructured database search quadratically. It is comprised of Hadamard gates, an oracle, controlled-Z gates, and a reflection. We will discuss each of these pieces in turn. First, here is a visual representation of the Grover circuit:</p>
<pre class="python"><code># from qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit
# from numpy import pi
# 
# qreg_q = QuantumRegister(2, &#39;q&#39;)
# creg_c = ClassicalRegister(2, &#39;c&#39;)
# circuit = QuantumCircuit(qreg_q, creg_c)
# 
# circuit.reset(qreg_q[0])
# circuit.reset(qreg_q[1])
# circuit.h(qreg_q[1])
# circuit.h(qreg_q[0])
# circuit.cz(qreg_q[0], qreg_q[1])
# circuit.h(qreg_q[1])
# circuit.h(qreg_q[0])
# circuit.x(qreg_q[0])
# circuit.x(qreg_q[1])
# circuit.cz(qreg_q[0], qreg_q[1])
# circuit.x(qreg_q[0])
# circuit.x(qreg_q[1])
# circuit.h(qreg_q[0])
# circuit.h(qreg_q[1])
# circuit.measure(qreg_q[0], creg_c[0])
# circuit.measure(qreg_q[1], creg_c[1])
# print (circuit)</code></pre>
<p><em>How does the seach work?</em>
Suppose you are given a large list of <span class="math inline">\(N\)</span> items. Among these items there is one item with a unique property that we wish to locate called <span class="math inline">\(w\)</span>. In general, <i>n</i> qubits are represented by a superposition state vector in <span class="math inline">\(2^{n}\)</span> dimensional Hilbert space, so our database contains <span class="math inline">\(N=2^n\)</span> items, which is dependent on the number of qubits.</p>
<p>In classical computation, the search (on average) would require checking <span class="math inline">\(N/2\)</span> items, and at worst all <span class="math inline">\(N\)</span> items. On a quantum computer, however, we can find the marked item in roughly <span class="math inline">\(\sqrt{N}\)</span> steps with Grover’s algorithm, which is a significant improvement to computational efficiency. Since the algorithm does not depend on the structure of the database itself, it can be used more generically.</p>
<p><em>The Hadamrad Gate</em>
The <b>Hadamard gate</b> is a single-qubit operation that creates an uniform superposition of the two basis states (a measurement of an output state will return 1 or 0 with equal probabilities).</p>
<p>In coordinates, the Hadamard gate applies the <i>Hadamard Matrix</i> to a coordinatized qubit:
<span class="math display">\[H=\frac{1}{\sqrt{2}}\begin{bmatrix}1 &amp; 1\\1 &amp; -1\end{bmatrix}\]</span></p>
<p>For example, maps the observational basis state |0⟩ to the superimposed state <span class="math inline">\(\frac{|0\rangle+|1\rangle}{\sqrt{2}}\)</span> and |1⟩ to <span class="math inline">\(\frac{|0\rangle-|1\rangle}{\sqrt{2}}\)</span></p>
<p>The Hadamard gate can also be considered geometrically as a 90º rotation of the Bloch Sphere about the Y-axis, followed by a 180º rotation about the X-axis.</p>
<p><i>Advanced Note</i>: The Hadamard gate is the lowest dimensional case (one-qubit) of the quantum Fourier transform.</p>
<p><em>The Oracle</em>
For this example, consider the database to be all the possible computational basis states our qubits can be in.
If we have 3 qubits, the states would run from <span class="math inline">\(|000\rangle, |001\rangle, \dots |111\rangle\)</span>.</p>
<p>Grover’s algorithm involves oracles that add a negative phase to the solution states. I.e. for any state <span class="math inline">\(|x\rangle\)</span> in the computational basis:</p>
<p><span class="math display">\[\begin{equation}
    f: \{0,1\}^n \mapsto \{0,1\} \mbox{ such that } f(w)=1 \mbox{ and } f(u)=0 \mbox{ for } u \not = w 
\end{equation}\]</span></p>
<p>We assume that we can implement this oracle as a quantum oracle.</p>
<p>Specifically, consider the unitary linear transformation of dimension <span class="math inline">\((n,n)\)</span>:</p>
<p><span class="math display">\[\begin{equation}
  U_w = I - 2|w&gt;&lt;w|  
\end{equation}\]</span></p>
<p>where <span class="math inline">\(|w&gt;\)</span> is the ket vector corresponding to the object <span class="math inline">\(w\)</span>. Then, it will act on any ket thusly:</p>
<p><span class="math display">\[
U_\omega|x\rangle = \bigg\{
\begin{aligned}
\phantom{-}|x\rangle \quad \text{if} \; x \neq \omega \\
-|x\rangle \quad \text{if} \; x = \omega \\
\end{aligned}
\]</span></p>
<p>This oracle will be a diagonal matrix, where the entry that correspond to the marked item will have a negative phase. For example, if we have three qubits and <span class="math inline">\(\omega = |101\rangle\)</span>, our oracle will have the matrix:</p>
<p><span class="math display">\[
U_\omega = 
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\begin{aligned}
\\
\\
\\
\\
\\
\\
\leftarrow \omega = \text{101}\\
\\
\\
\\
\end{aligned}
\]</span></p>
<p>We show this via direct computation. First, the outer product <span class="math inline">\(|w&gt;\)</span><span class="math inline">\(&lt;w|\)</span> is: <span class="math inline">\(|101&gt;\)</span><span class="math inline">\(&lt;101|\)</span> or</p>
<p><span class="math inline">\(\begin{bmatrix} 0\\ 0\\ 0\\ 0 \\ 0 \\ 1 \\ 0 \\ 0 \\ \end{bmatrix} * \begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ \end{bmatrix} = \begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ \end{bmatrix}\)</span> Then, multiplying by -2, we have <span class="math inline">\(= \begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -2 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ \end{bmatrix}\)</span></p>
<p>Finally, we add this matrix to our identity matrix=</p>
<p><span class="math inline">\(\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{bmatrix} + \begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -2 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ \end{bmatrix} \Rightarrow \begin{equation}U_w =\end{equation} \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{bmatrix}\)</span></p>
<p>There are many computational problems in which it’s difficult to <em>find</em> a solution, but relatively easy to <em>verify</em> a solution. For these problems, we can create a function <span class="math inline">\(f\)</span> that takes a proposed solution <span class="math inline">\(x\)</span>, and returns <span class="math inline">\(f(x) = 0\)</span> if <span class="math inline">\(x\)</span> is not a solution (<span class="math inline">\(x \neq \omega\)</span>) and <span class="math inline">\(f(x) = 1\)</span> for a valid solution (<span class="math inline">\(x = \omega\)</span>). Our oracle can then be described as:</p>
<p><span class="math display">\[
U_\omega|x\rangle = (-1)^{f(x)}|x\rangle
\]</span></p>
<p>and the oracle’s matrix will be a diagonal matrix of the form:</p>
<p><span class="math display">\[
U_\omega = 
\begin{bmatrix}
(-1)^{f(0)} &amp;   0         &amp; \cdots &amp;   0         \\
0           &amp; (-1)^{f(1)} &amp; \cdots &amp;   0         \\
\vdots      &amp;   0         &amp; \ddots &amp; \vdots      \\
0           &amp;   0         &amp; \cdots &amp; (-1)^{f(2^n-1)} \\
\end{bmatrix}
\]</span></p>
<p>Two things to verify are that <b><span class="math inline">\(U_w|w&gt; = -|w&gt;\)</span></b> and <b><span class="math inline">\(U_w|x&gt;=|x&gt;\)</span></b> for <span class="math inline">\(|x&gt;\)</span>, any of the <span class="math inline">\(n\)</span> vectors of the basis of <span class="math inline">\(\mathbb{C}^n\)</span>, with <span class="math inline">\(x \not = w\)</span>.</p>
<p><u>We verify that</u>
<span class="math inline">\(U_w|w&gt; = -|w&gt;\)</span>
<span class="math display">\[\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix} *\begin{bmatrix}
0\\
0\\
0\\
0 \\
0 \\
1 \\
0 \\
0 \\
\end{bmatrix} 
=
\begin{bmatrix}
0\\
0\\
0\\
0 \\
0 \\
-1 \\
0 \\
0 \\
\end{bmatrix}\]</span></p>
<p><strong>and</strong></p>
<p><span class="math inline">\(U_w|x&gt;=|x&gt;\)</span> for <span class="math inline">\(|x&gt;\)</span> where <span class="math inline">\(|x&gt;\)</span> is another ket in the database, say <span class="math inline">\(|001&gt;\)</span>:
<span class="math display">\[\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; -1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix} *\begin{bmatrix}
0\\
1\\
0\\
0 \\
0 \\
0 \\
0 \\
0 \\
\end{bmatrix} 
=
\begin{bmatrix}
0\\
1\\
0\\
0 \\
0 \\
0 \\
0 \\
0 \\
\end{bmatrix}\]</span></p>
<p>Thus, for an arbitrary ket <span class="math inline">\(|y&gt;\)</span>, the component of <span class="math inline">\(|y&gt;\)</span> in the direction <span class="math inline">\(|w&gt;\)</span> is reversed, while the components of <span class="math inline">\(|y&gt;\)</span> in all the directions orthogonal to <span class="math inline">\(w\)</span> are unchanged. Effectively, this corresponds to a reflection of <span class="math inline">\(|y&gt;\)</span> around the vector <span class="math inline">\(|y-w&gt;\)</span>.</p>
<p><a href="https://wucrypto-project.netlify.app/">here</a>.</p>
<p><em>Image from Spectrum.ieee</em></p>
